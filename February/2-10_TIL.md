# 수업 정리

---

### 도커

> 리눅스 컨테이너에 여러 기능을 추가하여 좀 더 쉽게 사용할 수 있도록 만든 오픈소스 프로젝트
> 

### ***로컬 서버 vs 가상 머신 vs 컨테이너 비교***

가상 머신

- 하이퍼바이저를 통한 가상화로 성능 손실 발생
- 완벽한 독립적 공간을 생성하나 이미지 용량이 크고 가상머신 배포에 부담

도커 컨테이너

- 리눅스 chroot, 네임 스페이스, Cgroup을 사용한 프로세스 단위 격리 환경 구성
- 애플리케이션 구동만을 위한 라이브러리만 포함한 이미지 생성, 용량 🔽
    
    ![2-10_1.jpeg](/images/2-10_1.jpeg)
    

### LXC (Linux Container)

> 리눅스 커널에 구현되어 있는 기술로 여러 기술을 조합하여 자원과 사용자를 분리하는 기능 (도커가 LXC를 기반으로 만들어진 상위레벨의 컨테이너 기술임)
> 

***chroot***

- 특정 디렉토리를 최상위 디렉토리 root로 인식하게 설정하는 리눅스 명령

***Cgroup***

- 시스템의 CPU, 메모리, IO, 대역폭 등의 자원을 제한하고 격리하여 과도한 자원 사용을 제한하는데 사용

***Namespace***

- 시스템 리소스를 해당 프로세스에만 해당되는 자원처럼 보이도록 하고 다른 프로세스와 격리시키는 가상화 기능
- 프로세스 자원을 관리하는 기능 - mnt, pid, net, ipc, user 등의 자원을 그룹화하여 할당

<aside>
⭐

위에 설명한 3가지 용어가 ‘컨테이너’라는 기능이 탄생할 수 있었던 리눅스 커널에서 제공하는 주요 기능

</aside>

### Docker Image

> 소스 코드, 라이브러리, 종속성, 도구 및 응용 프로그램을 실행하는데 필요한 기타 파일을 포함하는 불변 파일
> 
- 여러 개의 층으로 된 바이너리 파일로 존재
- 컨테이너 생성 시 읽기 전용으로 사용

### Docker Container

> 사용자가 기본 시스템에서 애플리케이션을 분리할 수 있는 가상화된 런타임 환경
> 
- 도커 이미지 목적에 맞게 컨테이너를 생성하는 것이 일반적임
    - ex) 웹 서버 도커 이미지로부터 여러 개의 컨테이너 생성 = 개수만큼의 웹서버
- 이미지를 읽기 전용으로 사용, 이미지 변경 데이터는 컨테이너 계층에 저장
- 컨테이너의 애플리케이션 설치/삭제는 다른 컨테이너에 영향 ❌

### Docker Volume

> 컨테이너는 삭제되어도 데이터는 유지하고 싶을 때 컨테이너 내부의 데이터를 외부로 링크를 걸어 데이터를 보존
> 
- 컨테이너 데이터를 영구적으로 보관하기 위한 저장 방식
- 호스트 볼륨을 공유, 볼륨 컨테이너, docker volume 이용 가능
- stateless 컨테이너
    - 데이터를 외부 볼륨에 저장하는 방식
- statefull 컨테이너
    - 데이터를 컨테이너 내부에 저장하는 방식

### 이미지 빌드

> Dockerfile vs 컨테이너 commit
> 
- **dockerfile build**
    - 도커파일은 이미지를 빌드하는데 필요한 모든 단계를 포함하므로, 이미지 빌드 과정을 완전히 재현 가능
    - 코드와 마찬가지로 버전 관리 시스템을 통해 관리할 수 있음
    - 이미지를 빌드하는데 필요한 모든 설정과 단계를 하나의 파일에 정의하므로 이미지의 구성을 쉽게 유지보수 할 수 있음
- **Container commit**
    - 간편하고 빠르게 시작할 수 있다 but dockerfile에 비해 단점이 많다
    - 컨테이너 커밋으로 생성된 이미지는 해당 컨테이너의 변경 사항만을 포함하므로 컨테이너 커밋을 통해 생성된 이미지를 다른 환경에서 재현하기 힘듦
    - 프로세스가 런타임 중 수행한 변경 사항을 포함할 수 있기 때문에 이미지의 일관성과 안정성이 보장되지 않을 수 있음
    - 이미지 실행 중인 컨테이너의 파일 시스템 변경 사항을 그대로 포함하므로 이미지 크기가 커질 수 있음

### Dockerfile 작성

![스크린샷 2025-02-10 오후 11.44.37.png](/images/2-10_2.png)

위와 같이 정의된 지시 사항에 따라 이미지를 빌드하여 도커 이미지로 저장할 수 있음

> Dockerfile 빌드
> 

`docker build [옵션] <경로>` 명령을 사용하여 이미지 구성 및 빌드

<경로> → 도커파일이 위치한 디렉토리의 경로

[옵션] → 이미지 빌드 과정을 조정하고 세부 사항을 지정

- -t, —tag : 빌드된 이미지에 태그 지정 이미지이름:태그 형식으로 사용
- -f, —file : 사용할 도커파일의 경로 지정 기본값 : ./Dock
- -q, —quiet : 빌드 진행 상황 메시지 출력 ❌
- —build-arg : 도커 파일 내에서 ARG 지시문에 전달할 빌드 인자 지정
    - ex) `docker build -t my-image:v1.0 .` → 현재 디렉토리에 위치한 도커파일을 사용하여 my-image라는 이미지를 빌드하고 태그를 v1.0으로 지정하라

> Dockerfile 작성 및 build 예시
> 

```bash
# 베이스 이미지 선택
FROM node:14

# 작업 디렉토리 설정
WORKDIR /app

# 애플리케이션 종속성 설치
COPY package.json package-lock.json /app/
RUN npm install

# 애플리케이션 파일 추가
COPY . /app/

# 포트 노출
EXPOSE 3000

# 컨테이너 실행 시 실행될 명령
CMD ["npm", "start"]
```

예를들어, 이렇게 node.js를 위한 dockerfile을 작성해준 후

```bash
docker build [옵션] [Dockerfile 경로]
docker build -t my-node-app .
```

현재 디렉토리 (.)에 위치한 Dockerfile을 이용하여 my-node-app이라는 이미지를 빌드

이렇게 빌드된 이미지는 docker run을 사용하여 컨테이너로 실행 가능

# 정보처리기사 필기 기출분석 (1, 2과목)

# 1과목 소프트웨어 설계

---

### 객체지향 분석 방법론

- Coad와 Yourdon 방법
    - E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성
- Booch(부치) 방법
    - 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법으로 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
- Jacobson 방법
    - Use Case를 강조하여 사용하는 분석 방법
- Wirfs-Brock 방법
    - 분석과 설계 간의 구분이 없고, 고객 명세서를 평가하여 설계 작업까지 연속적으로 수행
- Rumbaugh (럼바우) 방법
    - 객체 모델링 - 객체 다이어그램을 이용하여 객체들간의 관계 규정
    - 동적 모델링 - 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체 간의 동적인 행위 표현
    - 기능 모델링 - 자료 흐름도 (DFD)를 이용하여 다수의 프로세스 간의 자료 흐름을 중심으로 처리 과정 표현

### 미들웨어

- TP-Monitor
    - 트랜잭션이 올바르게 처리되고 있는지 데이터를 감시하고 제어하는 미들웨어
- RPC
    - 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출
- ORB
    - 객체 지향 미들웨어, CORBA 표준 스펙을 구현한 미들웨어

### 자료 흐름도 (DFD)

구성요소

- 프로세스
- Data Flow
- Data Store
- 단말 (Terminator)

### 자료 사전

- { } : 자료의 반복
- = : 자료의 정의
- + : 자료의 연결
- [ ] : 자료의 선택

### 소프트웨어 개발 단계

- 유지보수 단계 : 개발 비용이 가장 많이 소요

### UML

- 구성요소 : 사물 / 관계 / 다이어그램
- 구조, 정적 다이어그램 : (클객컴배복패) 클래스, 객체, 컴포넌트, 배치, 복합체, 패키지
- 행위, 동적 다이어그램 : (유시커상활타상) 유스케이스, 시퀀스, 커뮤니케이션, 상태, 활동, 타이밍, 상호작용 개요
    - 상태 다이어그램 : 하나의 객체가 가진 상태와 그 상태의 변화에 의한 동작순서
    - 객체들 사이에서 발생하는 이벤트에 의한 변화를 그림으로 표현
    - 시퀀스 다이어그램 : 객체들 사이의 메시지 교환
- 길러멧
    - 기본 기능 외에 추가적인 기능을 표현하는 스테레오 타입 (<< >>)

### UI

- 사용자의 편리성과 가독성을 높임
- 작업 시간 단축, 업무에 대한 이해도 높임

### 디자인 패턴

- 생성 패턴
    - Prototype
    - Abstract Factory
- 구조 패턴
    - Bridge
- 행위 패턴
    - Meditator

### 익스트림 프로그래밍(XP)

- 고객의 요구사항을 유연하게 대응하기 위해 고객 참여와 신속한 개발 과정 반복

### UI 설계 도구

- 스토리보드
    - 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서
- 프로토타입
    - 와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형
- 유스케이스
    - 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한 것
- 목업
    - 디자인, 사용방법 설명, 평가를 위해 실제 화면과 유사하게 만든 정적인 형태의 모형
    - 시각적으로만 구성 요소를 배치하는 것으로 실제로 구현되지는 않음

### 요구사항의 유형

- 기능적 요구
    - 실제 시스템 수행에 필요한 요구사항
- 비기능적 요구
    - 성능, 보안, 품질, 안전성 등 실제 수행에 보조적인 요구사항

### 컴포넌트

- 명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 인터페이스를 통해서만 접근 가능
- 넓은 의미
    - 재사용되는 모든 단위

### CASE

- 소프트웨어 개발 시 요구분석/설계/구현/검사 과정을 자동화 해주는 작업
- 원천 기술
    - 구조적 기법, 프로토타이핑 기술, 응용 프로그래밍 기술, 정보 저장소 기술, 분산처리 기술

# 2과목 소프트웨어 개발

---

### EAI (Enterprise Application Integration)

- 기업 응용 프로그램을 하나로 통합
- 구축 유형
    - Point-to-Point
    - Hub & Spoke
    - Message Bus(ESB)
    - Hybrid

### 인수 테스트

- 알파 테스트 : 통제된 환경에서 개발자와 함께 확인
- 베타 테스트 : 통제되지 않은 환경에서 개발자 없이 여러 명의 사용자가 검증

### 트리

차수

- 각 노드가 지닌 가지의 수 → 노드의 최대 차수 = 트리의 차수

### 해싱함수 종류

- 중첩(폴딩)법 : XOR 한 값을 홈 주소로 사용하는 방식
- 기수변환법 : 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수 절단 후 주소 범위에 맞게 조절
- 숫자분석법 : 키 값을 이루는 숫자의 분포를 분석하여 고른 자리를 필요한 만큼 택해서 홈 주소로 설정
- 제산법 : 레코드 키를 해시표의 크기보다 큰 수 중에서 가장 작은 소수로 나는 나머지를 홈 주소로 삼는 방식

### 소스 코드 품질 분석 도구

- 정적 분석 도구
    - pmd, cppcheck, checkstyle, SonarQube, Find Bug, cobertura, ccm
- 동적 분석 도구
    - Valance, Valgrind, Avalanche

### 소프트웨어 테스트

기초 경로

- 수행 가능한 모든 경로
