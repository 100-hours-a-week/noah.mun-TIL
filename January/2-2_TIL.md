# 이분탐색 / 투포인터

### BOJ 2805번 - 나무자르기

<aside>
📌

최소한 필요한 만큼의 나무를 자르기 위해 설정해야 하는 최대 높이를 정하는 문제임

</aside>

```python
def binary_search(st, en):
    sum = 0
    if st > en:
        return en

    mid = (st + en) // 2
    for hei in height:
        if hei >= mid:
            sum += (hei - mid)

    if sum == m:
        return mid
    elif sum > m:
        st = mid + 1
    else:
        en = mid - 1

    return binary_search(st, en)

n, m = map(int, input().split())
height = list(map(int, input().split()))

print(binary_search(1, max(height)))
```

- 이분 탐색을 사용하여 해결하는 전형적인 패턴의 문제 (이분 탐색을 좀 더 폭 넓게 사용할 줄 알아야 함..)
- 이분 탐색 함수 안에서 내가 설정한 절단기의 높이(mid)가 적절한 지 반복문을 일일히 돌면서 확인함 (추가적인 로직)
- 내가 계산한 총 가져갈 수 있는 나무(sum)이 가져가야 하는 나무(m)보다 크면, 내가 더 적게 가져가야 하니까 절단기의 높이(mid)를 올려야 함 → st = mid + 1
- 반대의 경우에는 en을 mid - 1로 바꿔 내가 가져가야 하는 나무의 양을 늘림
- ⭐ **이진 탐색에서 초기 start 값을 0으로 두는 이유 → height가 모두 같을 때 min(height)로 설정하면 나무가 한 개도 안 잘림**

---

### BOJ 2467 - 용액

<aside>
📌

이분탐색, 투포인터로 모두 풀 수 있는 문제였다. 하지만 나는 이분탐색으로 풀지 않고 투포인터로 풀었다. 그래서 투포인터 로직에 대해서 간단하게 설명하고 이분탐색 풀이법에 대해 알아볼 예정이다.

</aside>

```python
# 투포인터 풀이
n = int(input())
liquid = list(map(int, input().split()))

st = 0
en = n - 1
min = 2000000001

while st < en:
    if abs(liquid[st] + liquid[en]) < min:
        min = abs(liquid[st] + liquid[en])
        min_st = st
        min_en = en

    if liquid[st] + liquid[en] < 0:
        st += 1
    else:
        en -= 1

print(liquid[min_st], liquid[min_en])
```

- 어차피 0과 가까워지는 알고리즘이기 때문에 **(+ 오름차순으로 정렬되어 있음 → 이 말이 힌트)** 용액의 합 < 0 이면 st를 늘림 (음수가 세니까 음수를 더 약하게 만들어줌) 용액의 합 > 0 이면 en을 줄임 (양수가 세니까 양수를 더 약하게 만들어줌)

```python
# 이진 탐색 풀이
import sys
input = sys.stdin.readline

n = int(input())
liquids = list(map(int, input().split()))

ans = float("INF")
ans_left = 0
ans_right = 0

for i in range(n-1):
    current = liquids[i]

    start = i + 1
    end = n - 1

    while start <= end:
        mid = (start + end) // 2
        tmp = current + liquids[mid]

        if abs(tmp) < ans:
            ans = abs(tmp)
            ans_left = i
            ans_right = mid

            if tmp == 0:
                break
        
        if tmp < 0:
            start = mid + 1
        
        else:
            end = mid - 1

print(liquids[ans_left], liquids[ans_right])
```

- 반복문을 돌면서 용액의 i번째 값이랑 이진 탐색으로 구한 mid 값을 더해서 0과 가장 가까운 쌍을 찾는 방식 (근데 굳이 이분탐색으로 풀어야되나..?)
- 잘 모르겠긴 하지만… 이런 풀이도 있다~ 이런 식으로 한 번 알아두는 것도 나쁘지 않을 듯

---

# 정보처리기사 제 1과목 요약

### 소프트웨어 생명 주기

| 폭포수 | 선형 순차적 개발 / 고전적, 전통적 개발 모형 |
| --- | --- |
| HIPO | 하향식 설계 방식 / 이해 쉽고 유지보수 간단 |
| 프로토타입 | 고객의 니즈 파악을 위해 견본/시제품을 통해 최종 결과 예측
인터페이스 중심, 요구사항 변경 용이 |
| 나선형 | 폭포수 + 프로토타입 + 위험 분석 기능 추가 (최소화)
점진적 개발 과정 반복 / 정밀, 유지보수 필요 X
계획 수립 → 위험 분석 → 개발 및 검증 → 고객 평가 |
| 애자일 | 짧은 주기를 반복하며 개발 진행 → 고객 요구사항에 유연하게 대응 |

하향식 설계 (Top-down)

- 절차 지향 (순차적) / 최상위 컴포넌트 설계 후 하위 기능 부여 → 테스트 초기부터 사용자에게 시스템 구조 제시 가능
    - 컴포넌트 : 명백한 역할을 가지며 재사용되는 모든 단위 / 인터페이스를 통해 접근 가능

상향식 설계 (Bottom-up)

- 객체 지향 / 최하위 모듈 먼저 설계 후 이들을 결합하고 검사 → 인터페이스 구조 변경 시 상위 모듈도 같이 변경 필요하며 기능 추가가 어려움

### 스크럼(Scrum) 기법

| 제품 책임자
(Product Owner / PO) | 요구사항이 담긴 백로그 (Back log)를 작성 및 우선순위 지정
요구사항을 책임지고 의사결정 |
| --- | --- |
| 스크럼 마스터
(Scrum Master / SM) | 원활한 스크럼 위해 객관적 시각으로 조언 및 가이드 제시
진행사항 점검 및 장애요소 논의 후 해결 |
| 개발팀
(Development Team / DT) | PO와 SM을 제외한 모든 팀원
백로그에 스토리 추가 가능하나 우선순위는 지정 불가 |
- 스크럼 개발 프로세스
    
    스프린트 계획 회의 → 스프린트 → 일일 스크럼 회의 → 스프린트 검토 회의 → 스프린트 회고
    

### 익스트림 프로그래밍 (eXtreme Programming XP)

- 고객의 요구사항을 유연하게 대응하기 위해 고객 참여와 신속한 개발 과정을 반복
- 핵심 가치 : 용기, 단순성, 의사소통, 피드백, 존중
    - 피드백 : 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있게 도와줌
- 기본 원리 : 전체 팀 / 소규모 릴리즈 / 테스트 주도 개발 / 계속적인 통합 / 공동 소유권 / 짝 프로그래밍 / 디자인 개선 (리팩토링) / 애자일 방법론 활용
- 상식적 원리 및 경험 추구, **개발 문서보다는 소스코드에 중점 (문서화 X)**

### 요구사항

> 어떠한 문제를 해결하기 위해 필요한 조건 및 제약사항을 요구
소프트웨어 개발 / 유지 보수 과정에 필요한 기준과 근거 제공
> 
- 요구사항의 유형

| 기능적 요구 | 실제 시스템 수행에 필요한 요구사항
ex. 금융 시스템은 조회/인출/입금/송금 기능이 있어야 함 |
| --- | --- |
| 비기능적 요구 | 성능, 보안, 품질, 안정성 등 실제 수행에 보조적인 요구사항
ex. 모든 화면이 3초 이내에 사용자에게 보여야 한다. |
- ⭐ **요구사항 개발 프로세스**

| 1. 도출 / 추출 | 이해관계자들이 모여 요구사항 정의 (식별하고 이해하는 과정)
ex. 인터뷰, 설문, 브레인스토밍, 청취, 프로토타이핑, 유스케이스 |
| --- | --- |
| 2. 분석 | 사용자 요구사항에 타당성 조사 / 비용 및 일정에 대한 제약 설정
ex. 관찰, 개념 모델링, 정형 분석, 요구사항 정의 문서화 |
| 3. 명세 | 요구사항 체계적 분석 후 승인가능하도록 문서화 |
| 4. 확인 / 검증 | 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토 |
- 요구사항 분석 기법
    
    분류 / 개념 모델링 / 할당 / 협상 / 정형 분석
    
- 요구사항 확인 기법
    
    
    | 요구사항 검토 | 문서화된 요구사항을 확인 (일반적 방법) |
    | --- | --- |
    | 프로토타이핑 | 요구사항이 반영된 프로토타입 지속 제작 (피드백 후 반복 제작) |
    | 모델 검증 | 요구사항 분석 단계에서 개발된 모델이 충족되는지 검증 |
    | 인수 테스트 | 사용자 측면에서 실제 사용 환경 내 요구사항이 충족되는지 검증 |

### UML (Unified Modeling Language) 구성요소

- 사물 / 관계 / 다이어그램
    - 사물 : 구조 / 행동 / 그룹 / 주해
- 고객 / 개발자 간 원활한 의사소통을 위해 표준화한 대표적 객체지향 모델링 언어

| 연관 관계 | 2개 이상의 사물이 서로 관련 |
| --- | --- |
| 집합 관계 | 하나의 사물이 다른 사물에 포함 |
| 포함 관계 | 집합 관계의 특수 형태 |
| 일반화 관계 | 한 사물이 다른 사물에 비해 일반적 / 구체적인지 표현 |
| 의존 관계 | 사물 간 서로에게 영향을 주는 관계 |
| 실체화 관계 | 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정 / 서로를 그룹화할 수 있는 관계 |

| 구조, 정적 다이어그램 | 클래스 (Class) / 객체 (Object) / 컴포넌트 (Component) / 배치 (Deployment) / 복합체 (Composite) / 패키지 (Package) |
| --- | --- |
| 행위, 동적 다이어그램 | 유스케이스 (use case) : 사용자의 요구를 분석
순차 (Sequence) : 시스템 / 객체들이 주고받는 메시지 표현
      → 구성항목 : 액터 / 객체 / 생명선 / 메시지 / 제어 삼각형
커뮤니케이션 : 객체들 간의 연관까지 표현 
상태 : 상태가 어떻게 변화하는지 표현
활동 : 처리의 흐름을 순서에 따라 표현
타이밍 : 객체 상태 변화와 시간 제약을 명시적으로 표현
상호작용 개요 : 상호작용 다이어그램 간 제어 흐름 표현 |
- 액터 : 시스템과 상호작용하는 사람이나 다른 시스템에 의한 역할
    - 사용자 액터 : 기능을 요구하는 대상이나 시스템의 수행결과를 통보받는 사용자
    - 시스템 액터 : 본 시스템과 데이터를 주고 받는 연동 시스템

### User Interface (UI)

- 직관성, 유효성 (사용자의 목적 달성), 학습성, 유연성
- 설계 지침 : 사용자 중심 / 일관성 / 단순성 / 결과 예측 / 가시성 / 표준화 / 접근성 / 명확성 / 오류 발생 해결
- CLI (Command Line), GUI (Graphical), NUI (Natural), VUI (Voice), OUI (Organic)
- UI 설계 도구

| Wireframe | 기획 초기 단계에서 대략적인 레이아웃을 설계 |
| --- | --- |
| Story Board | 최종적인 산출문서 (와이어프레임-UI, 콘텐츠 구성, 프로세스 등) |
| Prototype | 와이어프레임 / 스토리보드에 인터랙션 적용
실제 구현된 것처럼 테스트가 가능한 동적인 형태 모형
- 인터랙션 : UI를 통해 시스템을 사용하는 일련의 상호작용 |
| Mockup | 실제 화면과 유사한 정적인 형태 모형 |
| Use case | 사용자 측면 요구사항 및 목표를 다이어그램으로 표현 |
- UI 프로토타입의 장/단점

| 장점 | 사용자를 설등하고 이해시키기 쉬움 / 사전에 오류 예방 가능
개발 시간 단축 (요구사항 및 기능의 불일치 방지) |
| --- | --- |
| 단점 | 반복적 개선 / 보완 작업으로 작업 시간 증가, 자원 소모
부분적 프로토타이핑 시 중요 작업 누락 및 생략 가능 |

---

# 리눅스마스터 1급

### 리눅스의 등장 배경에 대해서 공부
