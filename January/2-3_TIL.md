# kakao tech bootcamp 수업

---

|  | 정의 | 비고 |
| --- | --- | --- |
| 네트워크 | 컴퓨터, 모바일 기기 등 다양한 디바이스가 데이터를 주고받을 수 있도록 연결된 구조 |  |
| 랜 | 가까운 거리의 통신을 담당하는 통신망 |  |
| 왠 | 먼 거리의 통신을 담당하는 통신망 |  |
| 허브 | 여러 대의 네트워크 기기들을 연결해주는 장비 |  |
| 대역폭 | 데이터를 한 번에 전송할 수 있는 최대 속도 | 단위로 bps (bit per sec) 사용 |
| 스위치 | 한 네트워크 내의 장치 간 통신을 담당하는 장비 | 한 네트워크 내의 통신을 담당하기 때문에 MAC 주소 기반으로 동작 |
| 비트 | 데이터의 최소 단위0, 1로 구성 | 1 byte = 8 bit |
| 프로토콜 | 네트워크 기기간의 통신을 원활하게 하기 위해서 약속한 규약 |  |
| OSI 7계층 | 네트워크에서 통신하는 과정을 7단계로 나눔 | 통신 과정을 단계별로 한 눈에 파악할 수 있기 때문에 나눔 but 개념적으로 나눔 |
| TCP/IP 4계층 | OSI 7계층은 개념적으로 나누어져 있어 실제로 적용하기에 한계가 있음그래서 비슷한 계층을 하나로 묶음 | 유지보수가 쉬워서 실제로 적용하기 좋음 |
| 캡슐화 | 송신자가 데이터를 보내기 위해 포트 번호, ip, MAC 주소 등을 붙여 감싸는 것 |  |
| 역캡슐화 | 수신자가 캡슐화된 데이터를 받았을 때, 필요한 데이터를 얻기 위해 감싸진 정보를 뜯는 과정 |  |
| 트레일러 | 전송하는 데이터의 뒤에 붙어서 오류 발생 여부를 확인함 |  |
| VPN | 데이터 암호화가 필요할 때 사설망을 이용하여 ip주소, 데이터를 숨김 |  |
| 이더넷 | 1개의 네트워크 라인으로 여러 시스템이 통신 가능하도록 만든 구조 | 공유기, 허브 등을 사용해서 이더넷 실현 |
| CSMA/CD | 이더넷의 구조 중 하나로 여러 대의 시스템이 한 개의 라인을 사용하니까 충돌 가능성 높아짐 → 이를 해결하기 위한 방법론 | 데이터를 전송할 때 다른 시스템이 사용하지 않음을 확인하면 전송충돌나면 전송을 취소함 |
| MAC | 장치를 구분하는 하드웨어 주소 | 변경, 중복 X |
| ARP | 맥 주소를 사용하여 IP 주소를 알 수 있게 해주는 테이블 |  |
| IP | 통신에 필요한 주소 | 중복 X (공인 ip 기준) |
| 브로트캐스트 | 자신이 속한 네트워크 내에 있는 모든 장치들에게 패킷 전송N:1 통신 | 효율적이지는 X내가 보내고자하는 목적지 ip 위치가 어딘지 모를 때 사용 |
| 유니캐스트 | 출발지 주소와 목적지 주소를 정확하게 알고 있을 때 목적지 에만 전송1:1 통신 | 효율적임주소 관리를 잘해야 함 |
| 멀티캐스트 | 자신이 속한 네트워크 내 장치 중 원하는 장치들에게만 패킷 전송 | 멀티캐스트 주소 할당을 정확하게 해야 함 |
| 파싱(parsing) | 내가 원하는 데이터를 추출하는 과정 |  |
| METHOD | 객체 지향 프로그래밍에서 클래스 내부에 정의되어 있는 클래스의 동작 |  |
| Keepalive | 네트워크 통신에서 연결이 끊어지지 않도록 지속적으로 신호를 보내는 기술 | TCP 연결 유지, HTTP 연결 유지, 로드 밸런싱, 웹 소켓 등 다양한 네트워크 환경에서 사용
HTTP/1.1부터는 Keepalive 기본적으로 활성화 |
| DNS | Domain Name Systemwww.abc.com과 같은 주소 체계를 IP 주소 체계로 변환 |  |
| DHCP | IP, TCP/IP 프로토콜의 기본 설정 등을 동적으로 제공 |  |
| HTTP | 웹에서 데이터를 주고받는 프로토콜 |  |
| 헤더 | 데이터 + 데이터를 전송하기 위한 정보 |  |
| 라우팅 | 네트워크 안에서 통신할 때 목적지까지의 최적의 경로를 탐색하는 과정 | 다양한 라우팅 알고리즘이 있음(다익스트라, 벨만포드) |

# 정보처리기사 필기 - 소프트웨어 설계

---

### 소프트웨어 아키텍처

1. 모듈화
    - 시스템 기능을 모듈 단위로 분류하여 성능, 재사용성 향상
    - 모듈 크기 🔼 → 모듈 개수 🔽 → 모듈간 통합비용 🔽 → 모듈 당 개발 비용 🔼
    - 모듈 크기 🔽 → 모듈 개수 🔼 → 모듈간 통합비용 🔼
2. 추상화
    - 불필요한 부분은 생략하고 필요한 부분만 강조해 모델화
        - 문제의 포괄적인 개념을 설계 후 차례로 세분화하여 구체화 진행
    - 과정 추상화 : 자세한 수행 과정 정의 ❌, 전반적인 흐름만 파악가능하게 설계
    - 데이터(자료) 추상화 : 데이터의 세부적 속성, 용도 정의 ❌, 데이터 구조를 표현
    - 제어 추상화 : 이벤트 발생의 정확한 절차, 방법 정의 ❌, 대표 가능한 표현으로 대체

### 아키텍처 패턴

| Layer | 시스템을 계층으로 구분 / 구성하는 고전적 방식 (OSI 참조 모델) |
| --- | --- |
| Client-sever | 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
클라이언트와 서버는 요청, 응답 제외 시 서로 독립적
* 컴포넌트 : 독립적 업무/기능 수행 위한 실행코드 기반 모듈 |
| Pipe_Filter | 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화 후 데이터 전송 / 재사용 및 확장 용이 / 필터 컴포넌트 재배치 가능
단방향으로 흐르며, 필터 이동 시 오버헤드 발생
변환, 버퍼링, 동기화 적용 |
| Model-vidw Controller (MVC) | 모델 : 서브 시스템의 핵심 기능 및 데이터 보관
뷰 : 사용자에게 정보 표시
컨트롤러 : 사용자로부터 받은 입력 처리
→ 각 부분은 개별 컴포넌트로 분리되어 서로 영향 ❌
→ 하나의 모델 대상 다수 뷰 생성 - 대화형 애플리케이션에 적합 |

### 객체 지향

- 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어 분석

| 객체 | 고유 식별자 / 하나의 독립된 존재 / 일정한 기억장소 보유
상태 (state) = 객체가 가질 수 있는 조건, 속성 값에 의해 정의
행위 (Method) - 객체가 반응할 수 있는 메시지 집합 |
| --- | --- |
| 클래스 | 공통 속성과 연산을 갖는 객체들 집합 / 데이터 추상화 단위
* 인스턴스 - 클래스에 속한 각각의 객체
* Operation - 클래스의 동작 / 객체에 대해 적용될 메서드 정의 |
| 캡슐화 | 데이터와 데이터 처리 함수를 하나로 묶음
세부 내용 은폐 → 외부 접근 제한
결합도 🔽 / 재사용 용이 / 인터페이스 단순 / 오류 파급효과 🔽 |
| 상속 | 상위 클래스의 속성과 연산을 하위 클래스가 물려받는 것
* 다중 상속 - 단일 클래스가 두 개 이상의 상위 클래스로부터 상속 |
| 다형성 | 하나의 메시지에 각 객체 별 고유 특성에 따라 여러 형태의 응답 |
- 오버라이딩 (overriding)
    - 상위 클래스로부터 상속받은 메서드를 하위 클래스에서 재정의
        - 단, 메서드 이름, 매개변수, 반환 타입은 동일해야 함
- 오버로딩 (Overloading)
    - 메서드 이름은 동일하나 매개변수 개수 또는 타입을 다르게 지정

### 분석 방법론

- **Rumbaugh (럼바우)**
    - 객체 모델링 → 객체 다이어그램 / 객체들 간의 관계 규정
    - 동적 모델링 → 상태 다이어그램 / 시스템 행위 기술
    - 기능 모델링 → 자료 흐름도 / 다수의 프로세스들 간의 처리 과정 표현

### 5대 설계 원칙

- 단일 책임 원칙 (SRP)
    - 모든 클래스, 객체는 하나의 책임만 짐
    - 완전한 캡슐화
- 개방 폐쇄의 원칙 (OCP)
    - 확장에는 Open하고 수정에는 Close 되어야 함
- 리스코프 교체 원칙 (LSP)
    - 상위 클래스의 행동 규약을 하위 클래스가 위반해서는 안됨
- 인터페이스 분리 원칙 (ISP)
    - 클라이언트가 비사용 메서드에 의존해서는 ❌
- 의존성 역전 원칙 (DIP)
    - 의존 관계 수립 시 변화하기 어려운 것에 의존해야 함

# 리눅스마스터 1급 1차 - 2020 10월 필기 기출 분석

---

### GPL (General Public License)

- 어떠한 목적으로든지 사용 가능하나, 법으로 제한된 행위는 할 수 ❌
- 프로그램의 복사본은 소스 코드와 함께 판매하거나 소스 코드를 무료로 배포해야 함
- 소스 코드를 용도에 따라 변경 가능
- 변경된 프로그램도 소스 코드를 반드시 공개 배포
- 변경된 프로그램도 GPL 라이선스를 적용해야 함
- 자유 소프트웨어에서만 사용 가능

### MPL (Mozilla Public Licnese)

- BSD + GPL
- MPL 소스 코드 수정 시 소스 코드 공개는 필수
- MPL + 다른 소스 코드 결합 시 MPL 코드를 제외한 소스 코드는 공개하지 않아도 됨

### BSD (Berkeley Software Distribution)

- 누구나 수정한 것을 제한 없이 배포 가능
- 수정본의 재배포는 의무가 아니므로, **소스 코드 비공개 허용**

### LGPL (Library/Lesser General Public License)

- LGPL 라이브러리의 소스 코드를 수정했을 경우 소스 코드를 제공해야 함
- LGPL을 GPL로 변경 ⭕ GPL을 LGPL로 변경 ❌
- 자유 소프트웨어 + 독점 소프트웨어 사용 가능

---

### 리눅스 배포판의 분류

***SLS***

- 최초의 리눅스 배포판

***슬랙웨어 (Slackware)***

- upstream 방식으로 수정되어 배포
    - 사용자들이 내장된 프로그램을 사용하기 편함
- 패키지를 새롭게 적용하거나 수정이 힘듦
- **SuSE, Poreteus, Vector Linux, Salix OS**

***데비안 (Debian)***

- dpkg, apt라는 독자적인 패키지 관리 도구 사용
- **Knoppix, Corel, Lindows, Ubuntu, Linux Mint, Elementary OS, 백트랙, 칼리 리눅스**

***레드햇 (Red Hat)***

- RPM, YUM이라는 패키지 관리 도구 제공
- **RHEL, CentOS, Fedora, Oracle Linux, Scientific Linux, Asianux, Mandriva Linux, Mandrake**

---

### 운영체제

1. 리눅스 기반 운영체제
    - 구글 안드로이드, 마에모, 모블린, 리모, 타이젠, GENIVI, 바다 OS, 미고 (MeeGo), 리모 (LiMo), webOS
2. 유닉스 기반 운영체제
    - macOS, QNX

---

### 리눅스 클러스터링

<aside>
📖

여러 대의 컴퓨터를 연결하여 하나의 컴퓨터를 사용하는 것처럼 구성된 시스템

</aside>

1. 고계산용 클러스터(HPC)
    - 고성능의 계산 능력을 제공하기 위한 목적으로 제작 (과학계산용으로 활용)
        
        ![스크린샷 2025-02-03 오후 11.55.40.png](/images/2-3_1.png)
        
2. 부하분산 클러스터(LVS)
    - 대규모 서비스를 제공하기 위한 기법
    - 부하를 분산하는 로드 밸런서를 두고 운영
        
        ![스크린샷 2025-02-03 오후 11.56.32.png](/images/2-3_2.png)
        
3. 고가용성 클러스터(HA)
    - 지속적인 서비스 제공을 목적으로 부하분산 클러스터(LVS)에서 로드 밸런서에 오류가 생겨 동작하지 않는다면 리얼 서버가 정상적인 동작을 하더라도 서비스 제공 ❌
    - 이 문제점을 해결하기 위해
        - Primary Node가 부하분산 처리를 수행
        - Backup Node는 Primary Node에 이상이 발생하면 서비스를 이어받도록 구성
        
        ![스크린샷 2025-02-04 오전 12.01.10.png](/images/2-3_3.png)
        

---

UNIX는 켄 톰슨이 B 언어로 개발하고, 데니스 리치가 C 언어로 발전
